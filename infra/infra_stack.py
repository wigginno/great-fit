"""AWS CDK stack provisioning VPC, RDS PostgreSQL (serverless v2) and Secrets Manager secret."""
from aws_cdk import (
    Stack,
    CfnOutput,
    RemovalPolicy,
    Duration,
    aws_ec2 as ec2,
    aws_rds as rds,
    aws_secretsmanager as sm,
    aws_cloudwatch as cw,
    aws_cloudwatch_actions as cw_actions,
    aws_sns as sns,
    aws_sns_subscriptions as subs,
    aws_ecr as ecr,
    aws_iam as iam,
)
import aws_cdk.aws_apprunner_alpha as apprunner
from constructs import Construct
import os


class GreatFitInfraStack(Stack):
    """Infrastructure stack for Great Fit production deployment."""

    def __init__(self, scope: Construct, construct_id: str, **kwargs):
        super().__init__(scope, construct_id, **kwargs)

        # VPC across 2 AZs with public + isolated subnets
        vpc = ec2.Vpc(
            self,
            "GreatFitVpc",
            max_azs=2,
            subnet_configuration=[
                ec2.SubnetConfiguration(
                    name="public",
                    subnet_type=ec2.SubnetType.PUBLIC,
                    cidr_mask=24,
                ),
                ec2.SubnetConfiguration(
                    name="isolated",
                    subnet_type=ec2.SubnetType.PRIVATE_ISOLATED,
                    cidr_mask=24,
                ),
            ],
        )

        # Secrets Manager â€“ autogenerated master credentials
        db_secret = sm.Secret(
            self,
            "DbSecret",
            generate_secret_string=sm.SecretStringGenerator(
                exclude_punctuation=True,
                include_space=False,
                generate_string_key="password",
                secret_string_template='{"username":"gfadmin"}',
            ),
        )

        # RDS Aurora PostgreSQL Serverless v2 cluster
        cluster = rds.DatabaseCluster(
            self,
            "PostgresCluster",
            engine=rds.DatabaseClusterEngine.aurora_postgres(
                version=rds.AuroraPostgresEngineVersion.VER_15_5,
            ),
            writer=rds.ClusterInstance.serverless_v2("writer"),
            serverless_v2_min_capacity=0.5,   # ACUs
            serverless_v2_max_capacity=2,     # ACUs
            vpc=vpc,
            credentials=rds.Credentials.from_secret(db_secret),
            default_database_name="greatfit",
            subnet_group=rds.SubnetGroup(
                self,
                "DbSubnetGroup",
                description="Isolated subnets for RDS",
                vpc=vpc,
                subnet_group_name="gf-db-subnets",
                vpc_subnets=ec2.SubnetSelection(
                    subnet_type=ec2.SubnetType.PRIVATE_ISOLATED
                ),
            ),
            removal_policy=RemovalPolicy.DESTROY,
        )

        # --- Container Repository (import existing or ensure via workflow) --- #
        ecr_repo = ecr.Repository.from_repository_name(
            self, "AppRepository", repository_name="great-fit"
        )

        # --- App Runner Service --- #

        # Secret holding external API key (must exist beforehand)
        openrouter_secret_name = os.getenv("OPENROUTER_SECRET_NAME", "OPENROUTER_API_KEY")
        openrouter_secret = sm.Secret.from_secret_name_v2(
            self, "OpenRouterSecret", openrouter_secret_name
        )

        # Instance role to allow reading secrets
        instance_role = iam.Role(
            self,
            "AppRunnerInstanceRole",
            assumed_by=iam.ServicePrincipal("tasks.apprunner.amazonaws.com"),
        )
        db_secret.grant_read(instance_role)
        openrouter_secret.grant_read(instance_role)
        # Grant App Runner permissions to pull from ECR & read secrets
        instance_role.add_managed_policy(
            iam.ManagedPolicy.from_aws_managed_policy_name("AWSAppRunnerServicePolicyForECRAccess")
        )
        instance_role.add_managed_policy(
            iam.ManagedPolicy.from_aws_managed_policy_name("AWSAppRunnerServicePolicyForSecretsManagerAccess")
        )

        # DATABASE_URL using dynamic reference to password secret
        db_password = db_secret.secret_value_from_json("password").to_string()
        database_url = (
            f"postgresql://gfadmin:{db_password}@{cluster.cluster_endpoint.hostname}:5432/greatfit"
        )

        apprunner_service = apprunner.Service(
            self,
            "GreatFitAppRunner",
            source=apprunner.Source.from_ecr(
                repository=ecr_repo,
                tag_or_digest="latest",
                access_role=instance_role,
                port=8000,
            ),
            environment={
                "DATABASE_URL": database_url,
                "IMAGE_URI": f"{ecr_repo.repository_uri}:latest",
            },
            secrets={
                "OPENROUTER_API_KEY": apprunner.Secret.from_secrets_manager(openrouter_secret)
            },
            cpu=apprunner.Cpu.ONE_VCPU,
            memory=apprunner.Memory.TWO_GB,
        )

        # Outputs
        CfnOutput(self, "DbEndpoint", value=cluster.cluster_endpoint.hostname)
        CfnOutput(self, "DbSecretArn", value=db_secret.secret_arn)
        CfnOutput(self, "EcrRepoUri", value=ecr_repo.repository_uri)
        CfnOutput(self, "AppRunnerUrl", value=apprunner_service.service_url)

        # --- Monitoring & Alarms --- #
        # SNS topic for alarm notifications (add your email via env var ALERT_EMAIL or manually)
        alert_email = os.getenv("ALERT_EMAIL")
        topic = sns.Topic(self, "AlarmTopic", display_name="GreatFitAlarms")
        if alert_email:
            topic.add_subscription(subs.EmailSubscription(alert_email))

        # CPU Utilization alarm (>80% for 5 mins)
        cpu_metric = cluster.metric_cpu_utilization().with_(period=Duration.minutes(1))

        cpu_alarm = cw.Alarm(
            self,
            "DbHighCpu",
            metric=cpu_metric,
            evaluation_periods=3,
            datapoints_to_alarm=3,
            threshold=80,
            comparison_operator=cw.ComparisonOperator.GREATER_THAN_THRESHOLD,
            alarm_description="RDS Aurora CPU > 80%",
            alarm_name="GreatFit-RDS-HighCPU",
            actions_enabled=True,
        )

        # Wire alarm to SNS topic
        cpu_alarm.add_alarm_action(cw_actions.SnsAction(topic))

        # CloudWatch Dashboard
        dashboard = cw.Dashboard(self, "GreatFitDashboard", dashboard_name="GreatFit")
        dashboard.add_widgets(
            cw.GraphWidget(
                title="RDS CPU Utilization",
                left=[cpu_metric],
            )
        )
