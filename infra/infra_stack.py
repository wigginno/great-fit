"""AWS CDK stack provisioning VPC, RDS PostgreSQL (serverless v2) and Secrets Manager secret."""
from aws_cdk import (
    Stack,
    CfnOutput,
    RemovalPolicy,
    Duration,
    aws_ec2 as ec2,
    aws_rds as rds,
    aws_secretsmanager as sm,
    aws_cloudwatch as cw,
    aws_cloudwatch_actions as cw_actions,
    aws_sns as sns,
    aws_sns_subscriptions as subs,
    aws_ecr as ecr,
    aws_iam as iam,
    aws_cognito as cognito,
)
import aws_cdk.aws_apprunner_alpha as apprunner
from constructs import Construct
import os


class GreatFitInfraStack(Stack):
    """Infrastructure stack for Great Fit production deployment."""

    def __init__(self, scope: Construct, construct_id: str, **kwargs):
        super().__init__(scope, construct_id, **kwargs)

        # VPC across 2 AZs with public + isolated subnets
        vpc = ec2.Vpc(
            self, "GreatFitVpc",
            max_azs=2,
            nat_gateways=1,                    # shared NAT
            subnet_configuration=[
                ec2.SubnetConfiguration(       # 10.0.0.0/24 & 10.0.1.0/24
                    name="public",
                    subnet_type=ec2.SubnetType.PUBLIC,
                    cidr_mask=24,
                ),
                ec2.SubnetConfiguration(       # 10.0.2.0/24 & 10.0.3.0/24
                    name="isolated",
                    subnet_type=ec2.SubnetType.PRIVATE_ISOLATED,
                    cidr_mask=24,
                ),
                ec2.SubnetConfiguration(       # 10.0.4.0/24 & 10.0.5.0/24
                    name="private-egress",
                    subnet_type=ec2.SubnetType.PRIVATE_WITH_EGRESS,
                    cidr_mask=24,
                ),
            ],
        )

        # Secrets Manager â€“ autogenerated master credentials
        db_secret = sm.Secret(
            self,
            "DbSecret",
            generate_secret_string=sm.SecretStringGenerator(
                exclude_punctuation=True,
                include_space=False,
                generate_string_key="password",
                secret_string_template='{"username":"gfadmin"}',
            ),
        )

        user_pool_id_secret = sm.Secret.from_secret_name_v2(
            self,
            "UserPoolIdSecretLookup",
            "greatfit/userpool/id"
        )
        user_pool_arn_secret = sm.Secret.from_secret_name_v2(
            self,
            "UserPoolArnSecretLookup",
            "greatfit/userpool/arn"
        )
        user_pool_client_id_secret = sm.Secret.from_secret_name_v2(
            self,
            "UserPoolClientIdSecretLookup",
            "greatfit/userpool/clientid"
        )
        cognito_domain_secret = sm.Secret_from_secret_name_v2(
            self,
            "CognitoDomainSecretLookup",
            "greatfit/cognito/domain"
        )

        user_pool_id_string = user_pool_id_secret.secret_value_from_json(
            "GF_USER_POOL_ID"
        ).to_string()
        user_pool_arn_string = user_pool_arn_secret.secret_value_from_json(
            "GF_USER_POOL_ARN"
        ).to_string()
        user_pool_client_id_string = user_pool_client_id_secret.secret_value_from_json(
            "GF_USER_POOL_CLIENT_ID"
        ).to_string()
        cognito_domain_string = cognito_domain_secret.secret_value_from_json(
            "GF_COGNITO_DOMAIN"
        ).to_string()

        # RDS Aurora PostgreSQL Serverless v2 cluster
        cluster = rds.DatabaseCluster(
            self,
            "PostgresCluster",
            engine=rds.DatabaseClusterEngine.aurora_postgres(
                version=rds.AuroraPostgresEngineVersion.VER_15_5,
            ),
            writer=rds.ClusterInstance.serverless_v2("writer"),
            serverless_v2_min_capacity=0.5,   # ACUs
            serverless_v2_max_capacity=2,     # ACUs
            vpc=vpc,
            credentials=rds.Credentials.from_secret(db_secret),
            default_database_name="greatfit",
            subnet_group=rds.SubnetGroup(
                self,
                "DbSubnetGroup",
                description="Isolated subnets for RDS",
                vpc=vpc,
                subnet_group_name="gf-db-subnets",
                vpc_subnets=ec2.SubnetSelection(
                    subnet_type=ec2.SubnetType.PRIVATE_ISOLATED
                ),
            ),
            removal_policy=RemovalPolicy.DESTROY,
        )

        # --- Container Repository --- #
        ecr_repo = ecr.Repository.from_repository_name(
            self, "AppRepository", repository_name="great-fit"
        )

        # --- App Runner Service --- #

        # Secret holding external API key (must exist beforehand)
        openrouter_secret_name = os.getenv("OPENROUTER_SECRET_NAME", "OPENROUTER_API_KEY")
        openrouter_secret = sm.Secret.from_secret_name_v2(self, "OpenRouterSecret", openrouter_secret_name)

        # Instance role to allow reading secrets
        instance_role = iam.Role(
            self,
            "AppRunnerInstanceRole",
            assumed_by=iam.ServicePrincipal("tasks.apprunner.amazonaws.com"),
        )
        db_secret.grant_read(instance_role)
        openrouter_secret.grant_read(instance_role)
        user_pool_id_secret.grant_read(instance_role)
        user_pool_arn_secret.grant_read(instance_role)
        user_pool_client_id_secret.grant_read(instance_role)

        # Allow basic Cognito read actions (ListUsers for email lookup etc.)
        instance_role.add_to_policy(
            iam.PolicyStatement(
                effect=iam.Effect.ALLOW,
                actions=[
                    "cognito-idp:ListUsers",
                    "cognito-idp:GetUser",
                ],
                resources=[user_pool_arn_string],
            )
        )

        # DATABASE_URL using dynamic reference to password secret
        db_password = db_secret.secret_value_from_json("password").to_string()
        database_url = (
            f"postgresql://gfadmin:{db_password}@{cluster.cluster_endpoint.hostname}:5432/greatfit"
        )

        # --- Networking: allow App Runner to reach RDS via VPC Connector --- #
        # Security group for App Runner ENIs
        apprunner_sg = ec2.SecurityGroup(
            self,
            "AppRunnerSG",
            vpc=vpc,
            description="Security group for App Runner to access RDS",
            allow_all_outbound=True,
        )

        # Allow connections from App Runner to Postgres
        cluster.connections.allow_from(
            apprunner_sg,
            ec2.Port.tcp(5432),
            "App Runner access to Aurora Postgres"
        )

        vpc_connector = apprunner.VpcConnector(
            self,
            "AppVpcConnector",
            vpc=vpc,
            vpc_subnets=ec2.SubnetSelection(
                subnet_group_name="private-egress"
            ),
            security_groups=[apprunner_sg],
        )

        obs_cfg = apprunner.ObservabilityConfiguration(
            self, "Obs",
            observability_configuration_name="gf-default",
            trace_configuration_vendor=apprunner.TraceConfigurationVendor.AWSXRAY,
        )

        apprunner_service = apprunner.Service(
            self,
            "GreatFitAppRunner",
            source=apprunner.Source.from_ecr(
                repository=ecr_repo,
                tag_or_digest="latest",
                image_configuration=apprunner.ImageConfiguration(
                    port=8080,
                    environment_variables={
                        "DB_HOST": cluster.cluster_endpoint.hostname,
                        "DB_PORT": "5432",
                        "DB_NAME": "greatfit",
                        "DB_USER": "gfadmin",
                        "AWS_REGION": self.region,
                        "COGNITO_USER_POOL_ID": user_pool_id_string,
                        "COGNITO_APP_CLIENT_ID": user_pool_client_id_string,
                        "COGNITO_DOMAIN": cognito_domain_string,
                        "AUTH_BILLING_ENABLED": "true",
                    },
                    environment_secrets={
                        "DB_PASSWORD": apprunner.Secret.from_secrets_manager(
                            db_secret, field="password"
                        ),
                        "OPENROUTER_API_KEY": apprunner.Secret.from_secrets_manager(
                            openrouter_secret
                        ),
                    },
                ),
            ),
            cpu=apprunner.Cpu.ONE_VCPU,
            memory=apprunner.Memory.TWO_GB,
            instance_role=instance_role,
            vpc_connector=vpc_connector,
            observability_configuration=obs_cfg
        )

        # Outputs
        CfnOutput(self, "DbEndpoint", value=cluster.cluster_endpoint.hostname)
        CfnOutput(self, "DbSecretArn", value=db_secret.secret_arn)
        CfnOutput(self, "EcrRepoUri", value=ecr_repo.repository_uri)
        CfnOutput(self, "AppRunnerUrl", value=apprunner_service.service_url)

        # Cognito outputs
        CfnOutput(self, "UserPoolId", value=user_pool_id_string)
        CfnOutput(self, "UserPoolClientId", value=user_pool_client_id_string)
        # Ensure this output value matches the domain you are passing to the environment variable
        CfnOutput(self, "CognitoDomainUrl", value=f"https://{cognito_domain_string}")

        # --- Monitoring & Alarms --- #
        # SNS topic for alarm notifications (add your email via env var ALERT_EMAIL or manually)
        alert_email = os.getenv("ALERT_EMAIL")
        topic = sns.Topic(self, "AlarmTopic", display_name="GreatFitAlarms")
        if alert_email:
            topic.add_subscription(subs.EmailSubscription(alert_email))

        # CPU Utilization alarm (>80% for 5 mins)
        cpu_metric = cluster.metric_cpu_utilization().with_(period=Duration.minutes(1))

        cpu_alarm = cw.Alarm(
            self,
            "DbHighCpu",
            metric=cpu_metric,
            evaluation_periods=3,
            datapoints_to_alarm=3,
            threshold=80,
            comparison_operator=cw.ComparisonOperator.GREATER_THAN_THRESHOLD,
            alarm_description="RDS Aurora CPU > 80%",
            alarm_name="GreatFit-RDS-HighCPU",
            actions_enabled=True,
        )

        # Wire alarm to SNS topic
        cpu_alarm.add_alarm_action(cw_actions.SnsAction(topic))

        # CloudWatch Dashboard
        dashboard = cw.Dashboard(self, "GreatFitDashboard", dashboard_name="GreatFit")
        dashboard.add_widgets(
            cw.GraphWidget(
                title="RDS CPU Utilization",
                left=[cpu_metric],
            )
        )
